//
//  MessagesViewController.swift
//  TapperMessagesExtension
//
//  Created by Jules on [Current Date].
//

import UIKit
import SwiftUI // Import SwiftUI
import Messages

class MessagesViewController: MSMessagesAppViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        // Initial presentation will be handled by willBecomeActive or willTransition
        print("MessagesViewController loaded.")
    }

    // MARK: - Conversation Handling

    override func willBecomeActive(with conversation: MSConversation) {
        super.willBecomeActive(with: conversation)
        presentContentView(for: conversation, with: presentationStyle)
    }

    override func didResignActive(with conversation: MSConversation) {
        super.didResignActive(with: conversation)
        // Resources are managed by SwiftUI view's lifecycle or ARC.
        // You might remove child view controllers here if necessary,
        // but UIHostingController should handle its view's lifecycle.
        removeAllChildViewControllers()
    }

    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        // You might want to decode message.url or message.layout here
        // and update your UI or state accordingly.
        print("Received message: \(message.url?.absoluteString ?? "No URL")")
    }

    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
        // You can use this to, for example, clear the input fields after sending.
        print("Did start sending message.")
        // Potentially request compact mode or clear UI.
        // For now, ContentView handles its own state.
    }

    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
        // Use this to clean up state related to the deleted message.
        print("Did cancel sending message.")
    }

    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        super.willTransition(to: presentationStyle)
        guard let conversation = activeConversation else {
            print("Error: No active conversation found during transition.")
            return
        }
        presentContentView(for: conversation, with: presentationStyle)
    }

    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        super.didTransition(to: presentationStyle)
        // Finalize any behaviors associated with the change in presentation style if needed.
    }

    // MARK: - Present Content View

    private func presentContentView(for conversation: MSConversation, with presentationStyle: MSMessagesAppPresentationStyle) {
        // Remove any existing child view controllers to prevent overlap or multiple instances
        removeAllChildViewControllers()

        // Instantiate ContentView and pass `self` (MessagesViewController)
        // This allows ContentView to call `sendMessage` on this controller.
        let contentView = ContentView(messagesViewController: self)

        // Embed the SwiftUI view in a UIHostingController
        let hostingController = UIHostingController(rootView: contentView)

        addChild(hostingController)
        view.addSubview(hostingController.view)

        hostingController.view.frame = view.bounds
        hostingController.view.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            hostingController.view.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            hostingController.view.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            hostingController.view.topAnchor.constraint(equalTo: view.topAnchor),
            hostingController.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])

        hostingController.didMove(toParent: self)

        // If you need to do something specific for compact vs expanded, you can check presentationStyle
        // For this app, ContentView itself might adapt, or be the same.
        // For example, if presentationStyle == .compact {
        //    // Potentially configure hostingController or contentView differently
        // }
    }

    private func removeAllChildViewControllers() {
        for child in children {
            child.willMove(toParent: nil)
            child.view.removeFromSuperview()
            child.removeFromParent()
        }
    }

    // MARK: - Morse Image Generation

    func generateMorseImage(morseCode: String, desiredHeight: CGFloat) -> UIImage? {
        let dotSize = desiredHeight * 0.7 // Diameter of dot, height of dash
        let dashWidth = dotSize * 2.5
        let symbolSpacing: CGFloat = dotSize * 0.5      // Space between ./- in the same letter
        let letterEndSpacing: CGFloat = dotSize * 1.2   // Space after a letter (before next letter starts)
        let wordSeparatorCharacter: Character = "/" // Character used for word separation in morse string
        let wordSeparatorDisplaySpacing: CGFloat = dotSize * 2.0 // Visual space for a word separator

        var xOffset: CGFloat = 0
        var drawingOperations: [(CGRect, Bool)] = [] // Rect and isDot flag

        // Normalize Morse code: ensure single spaces between letters, and consistent word separator representation
        let cleanedMorse = morseCode.trimmingCharacters(in: .whitespacesAndNewlines)
                                   .replacingOccurrences(of: " / ", with: " \(wordSeparatorCharacter) ") // Standardize word separator
                                   .replacingOccurrences(of: "/", with: " \(wordSeparatorCharacter) ")    // Ensure spaces around standalone slash
                                   .split(separator: " ") // Split into components (letters or word separator)
                                   .map(String.init)
                                   .filter { !$0.isEmpty }


        for (i, component) in cleanedMorse.enumerated() {
            if component == String(wordSeparatorCharacter) {
                // This component represents a word space. Add its defined width.
                // The letterEndSpacing from any preceding letter component should have already been added.
                xOffset += wordSeparatorDisplaySpacing
            } else { // It's a letter
                let symbols = Array(component)
                for (j, symbol) in symbols.enumerated() {
                    var symbolRect: CGRect
                    var isDot = false
                    if symbol == "." {
                        symbolRect = CGRect(x: xOffset, y: (desiredHeight - dotSize) / 2, width: dotSize, height: dotSize)
                        xOffset += dotSize
                        isDot = true
                    } else if symbol == "-" {
                        symbolRect = CGRect(x: xOffset, y: (desiredHeight - dotSize) / 2, width: dashWidth, height: dotSize)
                        xOffset += dashWidth
                    } else {
                        continue // Should not happen if Morse string is clean
                    }
                    drawingOperations.append((symbolRect, isDot))

                    if j < symbols.count - 1 { // If not the last symbol in this letter component
                        xOffset += symbolSpacing
                    }
                }
            }
            if i < cleanedMorse.count - 1 { // If not the last component overall
                 // Add spacing after a letter component, unless the next is a word separator that handles its own spacing
                if component != String(wordSeparatorCharacter) && (i + 1 < cleanedMorse.count && cleanedMorse[i+1] != String(wordSeparatorCharacter)) {
                     xOffset += letterEndSpacing
                } else if component != String(wordSeparatorCharacter) && (i + 1 < cleanedMorse.count && cleanedMorse[i+1] == String(wordSeparatorCharacter)) {
                    // If a letter is followed by a word separator, add standard letter end spacing.
                    // The word separator will then add its specific additional spacing.
                    xOffset += letterEndSpacing
                }
            }
        }

        let totalWidth = max(xOffset, 1)

        if drawingOperations.isEmpty {
            // If morse code was just spaces or slashes, or empty.
            // Return nil if no actual dots/dashes to draw.
            if !cleanedMorse.joined().contains(".") && !cleanedMorse.joined().contains("-") {
                 print("No visual elements to draw for Morse: \(morseCode)")
                 return nil
            }
             // If after cleaning, it's empty, still return nil.
            if cleanedMorse.isEmpty { return nil }
        }


        let renderer = UIGraphicsImageRenderer(size: CGSize(width: totalWidth, height: desiredHeight))
        let image = renderer.image { context in
            // Use a color that is visible in both light and dark mode message bubbles.
            // UIColor.label dynamically adapts.
            UIColor.label.setFill()

            for operation in drawingOperations {
                let rect = operation.0
                let isDot = operation.1
                if isDot {
                    UIBezierPath(ovalIn: rect).fill()
                } else {
                    // For dashes, ensure they are vertically centered if dotSize is less than desiredHeight
                    let dashRect = CGRect(x: rect.origin.x, y: (desiredHeight - dotSize) / 2, width: rect.width, height: dotSize)
                    UIBezierPath(rect: dashRect).fill()
                }
            }
        }
        return image
    }


    // MARK: - Message Sending Logic

    func sendMessage(morse: String, text: String) {
        guard let conversation = activeConversation else {
            print("Error: No active conversation to send message.")
            return
        }

        let session = messageSession(for: conversation)
        let message = MSMessage(session: session)
        let layout = MSMessageTemplateLayout()

        // 1. Generate Morse Code Image
        // Let's define a typical height for the image, e.g., 30-40 points.
        let morseImageHeight: CGFloat = 30.0
        if let morseImage = generateMorseImage(morseCode: morse, desiredHeight: morseImageHeight) {
            layout.image = morseImage
        } else {
            // Fallback if image generation fails or not applicable (e.g. empty morse)
            // Could use a placeholder or just send text. For now, log and proceed.
            print("Could not generate Morse image, or Morse string was empty/invalid for image.")
            // If morse is not empty but image failed, we might still want to show it as text
            if !morse.isEmpty {
                 // As a fallback, put morse in subcaption if image is nil
                 // layout.subcaption = "Morse: \(morse)" // This is now the primary spot for morse text
            }
        }

        // 2. Set Caption and Subcaption
        layout.caption = text.isEmpty ? "Morse Code" : text // Decoded text
        layout.subcaption = morse // Raw Morse string

        // 3. Set Summary Text (for notifications, etc.)
        var summaryParts: [String] = []
        if !text.isEmpty { summaryParts.append("Text: \(text)") }
        if !morse.isEmpty { summaryParts.append("Morse: \(morse)") }
        message.summaryText = summaryParts.joined(separator: " - ")
        if message.summaryText!.isEmpty {
            message.summaryText = "Morse Code Message"
        }


        // 4. Construct URL with data
        var components = URLComponents()
        components.scheme = "morsetapper" // Define a custom scheme for your app
        components.host = "message"
        var queryItems = [URLQueryItem]()
        queryItems.append(URLQueryItem(name: "morse", value: morse))
        queryItems.append(URLQueryItem(name: "text", value: text))
        // queryItems.append(URLQueryItem(name: "version", value: "1.0")) // Optional: for future data versioning
        components.queryItems = queryItems
        message.url = components.url

        message.layout = layout

        conversation.insert(message) { [weak self] error in
            if let error = error {
                print("Error inserting message into conversation: \(error.localizedDescription)")
            } else {
                print("Message with custom layout inserted successfully.")
                // Optionally, clear UI or change presentation style
                // self?.requestPresentationStyle(.compact)
                // self?.dismiss()
            }
        }
    }

    // Helper to get or create an MSSession
    private func messageSession(for conversation: MSConversation) -> MSSession {
        // If the conversation already has a session from your app, use it. Otherwise, create a new one.
        // This helps in threading messages from your extension.
        return conversation.selectedMessage?.session ?? MSSession()
    }
}
